---
permalink: /digital_synth
layout: page
title: Digital Synth
page_title: Three Waveform Digital Synthesizer with ADSR Amplitude Envelope
---

![digi_synth](assets/imgs/digi_synth.jpg)

In this project I created a digital synthesizer with an ESP32, Midi Breakout Board, and PCM5102A DAC. Midi messages are received over UART by the ESP32 which then synthesizes PCM values based on the selected waveform and ADSR (Attack, Decay, Sustain, Release) enevelope settings. The PCM values are then sent to the PCM5102A DAC over I2S. The application running on the ESP32 was written in C and uses FreeRTOS tasks, queues, and notifications. The source code for this project can be found in this <a href=https://github.com/03predo/DigiSynth>git repository</a>. It can be broken up into two main blocks, the midi processing block and the audio processing block.

# Midi Processing Block
The midi processing block is responsible for handling incoming midi messages and notifying the audio processing block of any changes to the gate, pitch, attack, decay, sustain, and release of the current note being synthesized. Although midi uses a 5-pin DIN connector, it is essentially just UART with a baudrate of 31250. The midi breakout board has the hardware needed to obtain this UART signal from the 5-pin DIN connector. The midi processing block contains two FreeRTOS tasks, MidiRecv and MidiProc. This first task sets up the ESP32 uart driver which creates a queue that we wait on for UART events. On a UART_DATA event we read in the UART RX buffer. All midi messages are 3 bytes long so we read the buffer three bytes at a time and send these bytes to a Queue that the MidiProc task is waiting on.

The MidiProc task receives midi messages from the MidiRecv task and updates the stored state of the midi controller as well as notify the audio processing task when a message occurs. The state of the midi controller consists of the gate, which signifies the amount of active notes, pitch and pitch bend, which signifies the current note being played and how much bend to add to it, and the values of the mod wheel, faders, knobs, and buttons. When the MidiProc task receives a midi message it takes the first four bits to determine the message ID. Our application responds to 4 midi message IDs, Note Off, Note On, Control Change, and Pitch Bend. On a Note On event we increment the gate and update the pitch of the midi controller. We also store the note being pressed into a circular LIFO buffer. On a Note Off event we remove the note being released from the LIFO buffer, we then decrement the gate, and then check the LIFO buffer for the most recently pressed note that is still active and update the pitch to match this note. On a Control Change or Pitch Bend event we update the value of the fader bank, knob bank, button bank, mod wheel, or pitch bend. For all of these events, after updating the state of the midi controller we send a notification to the audio processing task with the corresponding midi event bit sent in the notification value.

# Audio Processing Block

The audio processing block contains one task that receives notifications from the midi processing block and then synthesizes PCM values that are then sent to the PCM5102A over I2S. The audio processing block contains two synthesizer components, the oscillator and the envelope generator.

## Digital Oscillator
The digital oscillator has three waveforms, a sin, sawtooth, and square wave, which can be selected through the midi controllers button bank. The state of the oscillator is stored in a struct which contains the waveform, angle, frequency, offset and the maximum and current amplitude. The three waveforms correspond to three functions that are normalized to have a period and amplitude of one, the current selection is stored in the oscillator struct as a function pointer. The angle of the oscillator indicates our current position in the period of our waveform. The offset is the amount we increment the angle per sample. The offset is calculated using the frequency. The maximum amplitude is set when the oscillator is initialized indicating the largest possible output of the oscillator. The current amplitude of the oscillator is a percentage of the maximum amplitude and is determined by the ADSR envelope.

## Envelope Generator
The envelope generator (EG) generates a 4-segment ADSR envelope used to control the current amplitude of the oscillator. The state of the EG is stored in the EnvelopeGenerator struct which contains the settings of the EG, curve generators for the attack, decay and release segment, the current segment the EG is in, and the previous amplitude of the EG. The math behind the envelope generator is taken from chapter 6 of Will Pirkle's, <a href="https://www.amazon.com/Designing-Software-Synthesizer-Plugins-Audio/dp/0367510464">Designing Software Synthesizer Plug-Ins in C++: For TackAFX, VST3, and Audio Units</a>. The settings of the EG contain the TCO for the curve generators. The TCO dictates the shape of the curve, closer to 1 it is more linear and closer to 0 it becomes more of a 90 degree angle. The settings also indicate the number of samples that the attack, decay, and release segments will last and the sustain level. The curve generators approximate exponential curves with iterative multiplication and addition. Every curve has a coefficient and offset that are determined by the envelope settings. The current amplitude is multiplied by the coefficient and added to the offset to obtain the next amplitude. When the attack segment is triggered the amplitude starts at zero and increases until it hits 1. At this point we transition into the decay segment where we decrease until we hit our sustain value, transitioning to the sustain segment. When the release segment is triggered we decrease down from our previous amplitude until we hit zero.

## Synthesizer Flow Diagram
The figure below shows a flow diagram of how the samples are synthesized. We first check if any new notifications have been sent to the task, if so we then check the value of the notification. If the notification is a Control Change then we need to update the current waveform and the settings of the envelope generator which will be explained in a later section. If the notification is a Note Off or Pitch Bend event then the frequency and the offset of the oscillator need to be updated. If the notification is a Note On event then we need to trigger the envelope to start the attack phase and also update the frequency and offset of the oscillator. Once we have handled any new notifications we check the gate of the midi controller. If it is 0 meaning there are no notes actively being pressed then we trigger the release phase of the envelope. We then use the EG to calculate our current amplitude and then calculate the waveform value at our current angle multiplied by our maximum possible altitude and the current amplitude given to us by the EG. After this we increment the angle by the offset and check to see if the angle is greater than 1. If it is then we reset the angle back by subtracting 1 from it. We repeat the calculations of the amplitude and waveform value until we have a block of samples that we then copy to the DMA which transfers them to the I2s peripheral.

![synth_flow](assets/imgs/synth_flow.jpg)

This video below shows the digital synthesizer in action. You can see me adjust the settings of the ADSR envelope with the 4 left-most faders in the bank and select the waveform with the 3 left-most buttons in the bank. The output of the DAC is shown on the oscilliscope display.


[![digital_synth](https://img.youtube.com/vi/oUR1ITL3Quo/0.jpg)](https://www.youtube.com/watch?v=oUR1ITL3Quo)
